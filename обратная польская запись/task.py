OPERATORS = {'+': (1, lambda x, y: x + y), '-': (1, lambda x, y: x - y),
             '*': (2, lambda x, y: x * y), '/': (2, lambda x, y: x / y)}



def parse(formula_string):
    """Генератор, получает на вход строку, возвращает числа в формате float, операторы и скобки в формате символов."""
    number = ''
    for s in formula_string:
        if s in '1234567890.':  # если символ - цифра, то собираем число
            number += s
        elif number:  # если символ не цифра, то выдаём собранное число и начинаем собирать заново
            yield float(number)
            number = ''
        if s in OPERATORS or s in "()":  # если символ - оператор или скобка, то выдаём как есть
            yield s
    if number:  # если в конце строки есть число, выдаём его
        yield float(number)


def shunting_yard(parsed_formula):
    stack = []  # в качестве стэка используем список
    for token in parsed_formula:
        # если элемент - оператор, то отправляем дальше все операторы из стека,
        # чей приоритет больше или равен пришедшему,
        # до открывающей скобки или опустошения стека.
        # здесь мы пользуемся тем, что все операторы право-ассоциативны
        if token in OPERATORS:
            while stack and stack[-1] != "(" and OPERATORS[token][0] <= OPERATORS[stack[-1]][0]:
                yield stack.pop()
            stack.append(token)
        elif token == ")":
            # если элемент - закрывающая скобка, выдаём все элементы из стека, до открывающей скобки,
            # а открывающую скобку выкидываем из стека.
            while stack:
                x = stack.pop()
                if x == "(":
                    break
                yield x
        elif token == "(":
            # если элемент - открывающая скобка, просто положим её в стек
            stack.append(token)
        else:
            # если элемент - число, отправим его сразу на выход
            yield token
    while stack:
        yield stack.pop()


def calc(polish):
    stack = []
    for token in polish:
        if token in OPERATORS:  # если приходящий элемент - оператор,
            y, x = stack.pop(), stack.pop()  # забираем 2 числа из стека
            stack.append(OPERATORS[token][1](x, y)) # вычисляем оператор, возвращаем в стек
        else:
            stack.append(token)
    return stack[0] # результат вычисления - единственный элемент в стеке



def eval_(formula_string):
    return calc(shunting_yard(parse(formula_string)))

argument = "1+2+4"


print(eval_(argument))

"""Необходимо написать приложение реализующее вычисление математических выражений.

Требования к программе

На вход будет подаваться строка, содержащая цифры и знаки сложения/вычитания/деления/умножения, например, 4.2 + 2 * 3 / 3 - 6.1.
Необходимо разобрать строку и вычислить результат математического выражения или сообщить об ошибке.

Выражение должно вводиться с клавиатуры через консоль. +
Допускается хранение исходной строки в переменной типа String. +

Кейсы, которые необходимо учесть:

В введенной строке с выражением не должно встречаться ничего, кроме цифр и знаков математических операций, в противном 
случае вы должны выбрасывать исключение и выводить понятное пользователю сообщение об ошибке.
Числа в выражении могут быть дробными. Используйте разделитель ..
При недопустимой операции, например деленние на 0, вы должны выбрасывать исключение и выводить сообщение об ошибке.
Не допускается введение некорректного выражения вида 4++2. Т.е. не может быть дублирующихся символов операций.
В выражении нельзя использовать скобки и соответственно, нельзя использовать отрицательные числа. Выражение вида -2+4 также считаем недопустимым.
Рекомендации к проектированию программы

Ожидается, что программа будет хорошо структурирована:
Будет создан отдельный класс для проверки валидации.
Будет создан класс разбора (парсинга) строки в выражение
Будет создан основной класс производящий математические вычисления
Будет создан класс для работы с консолью (чтения, вывода) и т.д.
Перед началом выполнения работы подумайте, как правильнее реализовать парсинг строки из операторов и операндов.
Удостоверьтесь, что вы не будете писать велосипед (посмотрите в сторону алгоритма обратной польской записи - рекомендуется использовать именно его).
Сделайте вашу программу легко расширяемой. Например, если вы захотите добавить новый оператор ^, который возводит число 
в степень, то в коде необходимо будет произвести минимум изменений.
Также рекомендуем перед началом разработки программы нарисовать архитектуру и дизайн вашего приложения.
Усложненный вариант задания

import operator

def calc(expr):
    OPERATORS = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}
    stack = [0]
    for token in expr.split(" "):
        if token in OPERATORS:
            op2, op1 = stack.pop(), stack.pop()
            stack.append(OPERATORS[token](op1,op2))
        elif token:
            stack.append(float(token))
    return stack.pop()
    """
